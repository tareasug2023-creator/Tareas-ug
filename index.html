<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Investigador Pro: El Juego de la Tesis</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        :root {
            --primary: #2563eb;
            --secondary: #7c3aed;
            --success: #10b981;
            --danger: #ef4444;
            --dark: #1f2937;
            --light: #f3f4f6;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: var(--dark);
        }

        #app {
            background: white;
            width: 95%;
            max-width: 900px;
            border-radius: 24px;
            padding: 2rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }

        .screen { display: none; animation: slideIn 0.4s ease-out; }
        .active { display: block; }

        @keyframes slideIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        .hud {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            background: var(--light);
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 20px;
            font-weight: 600;
            font-size: 0.9rem;
        }

        button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            margin: 5px;
        }

        button:hover:not(:disabled) { transform: translateY(-2px); filter: brightness(1.1); }
        button:disabled { background: #ccc; cursor: not-allowed; }

        .grid-memory {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 20px 0;
        }

        .card {
            height: 85px;
            background: var(--primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 10px;
            font-size: 0.75rem;
            padding: 5px;
            text-align: center;
            transition: 0.3s;
            font-weight: 600;
        }

        .card.flipped { background: var(--secondary); }
        .card.matched { background: var(--success); opacity: 0.6; cursor: default; }

        .matching-container {
            display: flex;
            justify-content: space-between;
            position: relative;
            margin-top: 20px;
            gap: 50px;
        }
        .match-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 2;
            width: 45%;
        }
        .match-item {
            padding: 15px;
            background: var(--light);
            border: 2px solid #ddd;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.85rem;
            text-align: center;
            transition: 0.3s;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .match-item.selected { border-color: var(--secondary); background: #e0d4ff; }
        .match-item.correct { border-color: var(--success); background: #d1fae5; cursor: default; }
        
        canvas#line-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1;
        }

        .hangman-hint {
            background-color: #fef3c7;
            border-left: 5px solid #f59e0b;
            color: #92400e;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 4px;
            font-style: italic;
            font-size: 0.95rem;
        }
        .hangman-word { font-size: 2.2rem; letter-spacing: 12px; margin: 15px 0; font-weight: 800; color: var(--secondary); text-align: center; text-transform: uppercase;}
        .alphabet { display: flex; flex-wrap: wrap; justify-content: center; gap: 5px; margin-top: 10px; }

        .ranking-box {
            border: 2px solid var(--light);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            background: #fafafa;
        }

        .ranking-table-container {
            margin-top: 20px;
            overflow-x: auto;
            border-radius: 12px;
            border: 1px solid #eee;
        }
        .ranking-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            background: white;
        }
        .ranking-table th {
            background: var(--primary);
            color: white;
            padding: 10px;
            text-align: center;
        }
        .ranking-table td {
            padding: 10px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }
        .ranking-table tr:last-child td { border-bottom: none; }

        .final-leaderboard {
            margin-top: 30px;
            padding: 20px;
            background: #fff;
            border: 3px solid var(--secondary);
            border-radius: 15px;
        }

        /* Estilo para la tabla del men√∫ inicial */
        .initial-ranking {
            margin-top: 25px;
            background: var(--light);
            padding: 15px;
            border-radius: 15px;
        }

        .progress-bar {
            height: 8px;
            background: #eee;
            border-radius: 4px;
            margin-bottom: 20px;
        }

        #progress-fill {
            height: 100%;
            background: var(--success);
            width: 0%;
            transition: 0.5s;
        }
    </style>
</head>
<body>

<div id="app">
    <div id="screen-setup" class="screen active">
        <h1 style="text-align: center; color: var(--primary);">üéì Tesis Master: El Desaf√≠o</h1>
        <p style="text-align: center;">Domina la metodolog√≠a a trav√©s de retos din√°micos.</p>
        <label>Nombre del Investigador:</label>
        <input type="text" id="player-name" placeholder="Ej. Dr. Garc√≠a" style="width:100%; padding:12px; margin:10px 0; border:2px solid var(--light); border-radius:10px;">
        <label>Nivel de Dificultad:</label>
        <select id="difficulty" style="width:100%; padding:12px; margin:10px 0; border:2px solid var(--light); border-radius:10px;">
            <option value="F√°cil">F√°cil</option>
            <option value="Medio">Medio</option>
            <option value="Dif√≠cil">Dif√≠cil</option>
        </select>
        <button onclick="initGame()" style="width: 100%; margin-top: 20px;">INICIAR INVESTIGACI√ìN</button>

        <div class="initial-ranking" id="historical-ranking-section">
            <h3 style="text-align: center; font-size: 1rem; color: var(--secondary); margin-top: 0;">üèÜ RANKING HIST√ìRICO</h3>
            <div class="ranking-table-container">
                <table class="ranking-table">
                    <thead>
                        <tr>
                            <th>Investigador</th>
                            <th>Dificultad</th>
                            <th>Puntaje Total</th>
                        </tr>
                    </thead>
                    <tbody id="historical-ranking-body">
                        </tbody>
                </table>
            </div>
            <button onclick="clearRanking()" style="background: var(--danger); font-size: 0.7rem; padding: 5px 10px; margin-top: 10px;">Limpiar Ranking</button>
        </div>
    </div>

    <div id="screen-game" class="screen">
        <div class="hud">
            <div>‚ù§Ô∏è <span id="lives">5</span></div>
            <div>‚è±Ô∏è <span id="timer">0</span>s</div>
            <div>‚≠ê <span id="score">0</span></div>
            <div>üìç Nivel <span id="lvl-num">1</span></div>
        </div>
        <div class="progress-bar"><div id="progress-fill"></div></div>
        <h2 id="level-topic" style="color: var(--secondary); margin-bottom: 5px;"></h2>
        <h4 id="activity-desc" style="margin-top: 0; color: #666;"></h4>
        <div id="game-content"></div>
    </div>

    <div id="screen-rank" class="screen">
        <h2 id="rank-title" style="text-align: center;"></h2>
        <div class="ranking-box">
            <p>Tiempo empleado: <strong id="rank-time"></strong>s</p>
            <p>Vidas restantes: <strong id="rank-lives"></strong></p>
            <p>Puntaje obtenido: <strong id="rank-score"></strong></p>
            <hr>
            <h3 id="rank-grade" style="text-align: center; font-size: 2rem; margin-bottom: 10px;"></h3>
            
            <div class="ranking-table-container">
                <table class="ranking-table">
                    <thead>
                        <tr>
                            <th>Nivel</th>
                            <th>Dificultad</th>
                            <th>Tiempo</th>
                            <th>Vidas</th>
                            <th>Puntaje</th>
                        </tr>
                    </thead>
                    <tbody id="ranking-body">
                    </tbody>
                </table>
            </div>

            <div id="final-leaderboard-container" class="final-leaderboard" style="display: none;">
                <h3 style="text-align: center; color: var(--secondary);">üèÜ TABLA DE PUESTOS FINAL</h3>
                <table class="ranking-table">
                    <thead>
                        <tr>
                            <th>Nombre</th>
                            <th>Dificultad</th>
                            <th>Porcentaje √âxito</th>
                        </tr>
                    </thead>
                    <tbody id="leaderboard-body">
                    </tbody>
                </table>
            </div>
        </div>
        <button id="btn-next-lvl" onclick="startLevel(gameState.currentLevel + 1)" style="width: 100%; margin-top: 20px;">Siguiente Nivel ‚û°</button>
    </div>
</div>

<script>
    const gameState = {
        playerName: "",
        difficulty: "F√°cil",
        currentLevel: 1,
        currentActivity: 0,
        lives: 5,
        score: 0,
        lvlTime: 0,
        timerInterval: null,
        selectedMatch: null,
        rankingHistory: [] 
    };

    const levelsData = {
        1: { 
            title: "Variables Independiente y Dependiente", 
            activities: [
                { type: "connect", pairs: [
                    {a: "Causa", target: "Independiente"}, {a: "Manipulada", target: "Independiente"},
                    {a: "Efecto", target: "Dependiente"}, {a: "Medida", target: "Dependiente"}
                ], rightOptions: ["Independiente", "Dependiente", "Independiente", "Dependiente"] },
                { type: "memory", pairs: [
                    {text: "X", target: "Independiente"}, {text: "Independiente", target: "Independiente"},
                    {text: "Y", target: "Dependiente"}, {text: "Dependiente", target: "Dependiente"},
                    {text: "Est√≠mulo", target: "Independiente"}, {text: "Causa", target: "Independiente"},
                    {text: "Respuesta", target: "Dependiente"}, {text: "Efecto", target: "Dependiente"}
                ]},
                { type: "hangman", word: "DEPENDIENTE", hint: "Es la variable que representa el efecto o resultado que se mide en la investigaci√≥n." }
            ]
        },
        2: { 
            title: "Planteamiento del Problema", 
            activities: [
                { type: "connect", pairs: [
                    {a: "Espacio", target: "Geogr√°fico"}, {a: "Tiempo", target: "Cronol√≥gico"}, 
                    {a: "Sujetos", target: "Poblaci√≥n"}, {a: "Vac√≠o", target: "Conocimiento"}
                ], rightOptions: ["Geogr√°fico", "Cronol√≥gico", "Poblaci√≥n", "Conocimiento"] },
                { type: "hangman", word: "DELIMITACION", hint: "Acci√≥n de establecer los l√≠mites f√≠sicos, temporales y conceptuales de la investigaci√≥n." },
                { type: "select", q: "El planteamiento debe ser:", options: ["Vago", "Preciso y medible", "Subjetivo"], correct: 1 }
            ]
        },
        3: { 
            title: "Objetivos de la Tesis", 
            activities: [
                { type: "hangman", word: "INFINITIVO", hint: "Forma verbal (Ar, Er, Ir) con la que deben iniciar obligatoriamente los objetivos." },
                { type: "connect", pairs: [
                    {a: "Verbo inicial", target: "Infinitivo"}, {a: "Pasos", target: "Espec√≠ficos"}, 
                    {a: "Meta final", target: "General"}, {a: "Atributo", target: "Medible"}
                ], rightOptions: ["Infinitivo", "Espec√≠ficos", "General", "Medible"] }
            ]
        },
        4: { 
            title: "Justificaci√≥n de la Tesis", 
            activities: [
                { type: "connect", pairs: [
                    {a: "Social", target: "Beneficiarios"}, {a: "Te√≥rica", target: "Vac√≠o cognitivo"}, 
                    {a: "Pr√°ctica", target: "Soluci√≥n"}, {a: "Metodol√≥gica", target: "Instrumento"}
                ], rightOptions: ["Beneficiarios", "Vac√≠o cognitivo", "Soluci√≥n", "Instrumento"] },
                { type: "hangman", word: "VIABILIDAD", hint: "Indica si la investigaci√≥n es posible de realizar con los recursos disponibles." }
            ]
        },
        5: { 
            title: "Operacionalizaci√≥n", 
            activities: [
                { type: "connect", pairs: [
                    {a: "Variable", target: "Concepto"}, {a: "Dimensi√≥n", target: "Subvariable"}, 
                    {a: "Indicador", target: "Unidad"}, {a: "√çtem", target: "Pregunta"}
                ], rightOptions: ["Concepto", "Subvariable", "Unidad", "Pregunta"] },
                { type: "hangman", word: "INDICADOR", hint: "Elemento concreto y medible que permite verificar el estado de una dimensi√≥n." }
            ]
        }
    };

    // FUNCI√ìN PARA CARGAR RANKING HIST√ìRICO
    function loadHistoricalRanking() {
        const ranking = JSON.parse(localStorage.getItem('tesis_ranking')) || [];
        const tbody = document.getElementById('historical-ranking-body');
        tbody.innerHTML = "";
        
        // Ordenar por puntaje de mayor a menor
        ranking.sort((a, b) => b.total - a.total);

        ranking.slice(0, 5).forEach(player => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td style="font-weight:bold">${player.name}</td>
                <td>${player.diff}</td>
                <td style="color:var(--primary); font-weight:800">${player.total}</td>
            `;
            tbody.appendChild(tr);
        });
    }

    function clearRanking() {
        localStorage.removeItem('tesis_ranking');
        loadHistoricalRanking();
    }

    function saveToHistoricalRanking() {
        const ranking = JSON.parse(localStorage.getItem('tesis_ranking')) || [];
        let totalScore = 0;
        gameState.rankingHistory.forEach(item => totalScore += item.score);
        
        ranking.push({
            name: gameState.playerName,
            diff: gameState.difficulty,
            total: totalScore
        });

        localStorage.setItem('tesis_ranking', JSON.stringify(ranking));
    }

    function initGame() {
        gameState.playerName = document.getElementById('player-name').value || "Investigador";
        gameState.difficulty = document.getElementById('difficulty').value;
        startLevel(1);
    }

    function startLevel(num) {
        if(num > 5) return;
        gameState.currentLevel = num;
        gameState.currentActivity = 0;
        gameState.lvlTime = 0;
        gameState.lives = 5;
        gameState.score = 0;
        showScreen('screen-game');
        updateHUD();
        if(gameState.timerInterval) clearInterval(gameState.timerInterval);
        gameState.timerInterval = setInterval(() => {
            gameState.lvlTime++;
            document.getElementById('timer').innerText = gameState.lvlTime;
        }, 1000);
        nextActivity();
    }

    function nextActivity() {
        const lvl = levelsData[gameState.currentLevel];
        if(gameState.currentActivity >= lvl.activities.length) { endLevel(); return; }
        const activity = lvl.activities[gameState.currentActivity];
        const container = document.getElementById('game-content');
        const desc = document.getElementById('activity-desc');
        container.innerHTML = "";
        document.getElementById('level-topic').innerText = lvl.title;
        document.getElementById('lvl-num').innerText = gameState.currentLevel;
        document.getElementById('progress-fill').style.width = `${(gameState.currentActivity / lvl.activities.length) * 100}%`;

        if(activity.type === "memory") renderMemory(activity.pairs);
        else if(activity.type === "hangman") renderHangman(activity.word, activity.hint);
        else if(activity.type === "select") renderSelect(activity);
        else if(activity.type === "connect") renderConnect(activity.pairs, activity.rightOptions);
    }

    function renderHangman(word, hint) {
        const container = document.getElementById('game-content');
        const hintDiv = document.createElement('div');
        hintDiv.className = 'hangman-hint';
        hintDiv.innerHTML = `<strong>Pista:</strong> ${hint}`;
        container.appendChild(hintDiv);
        let guessed = [];
        const wordDiv = document.createElement('div');
        wordDiv.className = 'hangman-word';
        const updateWord = () => {
            wordDiv.innerText = word.split('').map(l => guessed.includes(l) ? l : "_").join("");
            if(!wordDiv.innerText.includes("_")) successStep();
        };
        const alphabetDiv = document.createElement('div');
        alphabetDiv.className = 'alphabet';
        "ABCDEFGHIJKLMN√ëOPQRSTUVWXYZ".split("").forEach(l => {
            const btn = document.createElement('button');
            btn.innerText = l;
            btn.onclick = () => {
                btn.disabled = true;
                if(word.includes(l)) { guessed.push(l); updateWord(); }
                else handleError();
            };
            alphabetDiv.appendChild(btn);
        });
        container.appendChild(wordDiv);
        container.appendChild(alphabetDiv);
        updateWord();
    }

    function renderMemory(pairs) {
        const container = document.getElementById('game-content');
        const grid = document.createElement('div');
        grid.className = 'grid-memory';
        let deck = [...pairs].sort(() => Math.random() - 0.5);
        let flipped = [];
        deck.forEach((item) => {
            const card = document.createElement('div');
            card.className = 'card';
            card.innerText = "‚ùî";
            card.dataset.target = item.target;
            card.onclick = () => {
                if(flipped.length < 2 && !card.classList.contains('flipped') && !card.classList.contains('matched')) {
                    card.innerText = item.text;
                    card.classList.add('flipped');
                    flipped.push(card);
                    if(flipped.length === 2) {
                        if(flipped[0].dataset.target === flipped[1].dataset.target) {
                            flipped.forEach(c => { c.classList.add('matched'); c.classList.remove('flipped'); });
                            flipped = [];
                            gameState.score += 100;
                            if(document.querySelectorAll('.card.matched').length === deck.length) setTimeout(successStep, 800);
                        } else {
                            setTimeout(() => { flipped.forEach(c => { c.innerText = "‚ùî"; c.classList.remove('flipped'); }); flipped = []; handleError(); }, 1000);
                        }
                    }
                }
            };
            grid.appendChild(card);
        });
        container.appendChild(grid);
    }

    function renderConnect(pairs, rightOptions) {
        const container = document.getElementById('game-content');
        const wrapper = document.createElement('div');
        wrapper.className = 'matching-container';
        const canvas = document.createElement('canvas');
        canvas.id = 'line-canvas';
        wrapper.appendChild(canvas);
        const colA = document.createElement('div'); colA.className = 'match-column';
        const colB = document.createElement('div'); colB.className = 'match-column';
        const itemsA = pairs.map(p => ({txt: p.a, target: p.target})).sort(() => Math.random() - 0.5);
        const itemsB = rightOptions.map(opt => ({txt: opt})).sort(() => Math.random() - 0.5);
        itemsA.forEach(item => {
            const div = document.createElement('div'); div.className = 'match-item'; div.innerText = item.txt; div.dataset.target = item.target; div.onclick = () => handleMatchSelect(div, 'A'); colA.appendChild(div);
        });
        itemsB.forEach(item => {
            const div = document.createElement('div'); div.className = 'match-item'; div.innerText = item.txt; div.dataset.value = item.txt; div.onclick = () => handleMatchSelect(div, 'B'); colB.appendChild(div);
        });
        wrapper.appendChild(colA); wrapper.appendChild(colB); container.appendChild(wrapper);
        setTimeout(() => { canvas.width = wrapper.offsetWidth; canvas.height = wrapper.offsetHeight; }, 100);
    }

    function handleMatchSelect(el, side) {
        if(el.classList.contains('correct')) return;
        if(gameState.selectedMatch && gameState.selectedMatch.side === side) gameState.selectedMatch.el.classList.remove('selected');
        el.classList.add('selected');
        if(!gameState.selectedMatch) gameState.selectedMatch = {el, side};
        else {
            if(gameState.selectedMatch.side !== side) {
                const nodeA = side === 'A' ? el : gameState.selectedMatch.el;
                const nodeB = side === 'B' ? el : gameState.selectedMatch.el;
                if(nodeA.dataset.target === nodeB.dataset.value) {
                    nodeA.classList.add('correct'); nodeB.classList.add('correct'); drawConnectLine(nodeA, nodeB); gameState.score += 150;
                    if(document.querySelectorAll('.match-item.correct').length === 8) setTimeout(successStep, 1000);
                } else {
                    handleError(); nodeA.classList.remove('selected'); nodeB.classList.remove('selected');
                }
                gameState.selectedMatch = null;
            } else { gameState.selectedMatch = {el, side}; }
        }
    }

    function drawConnectLine(el1, el2) {
        const canvas = document.getElementById('line-canvas');
        if(!canvas) return;
        const ctx = canvas.getContext('2d');
        const rect = canvas.getBoundingClientRect();
        const b1 = el1.getBoundingClientRect();
        const b2 = el2.getBoundingClientRect();
        ctx.beginPath();
        ctx.moveTo(b1.right - rect.left, b1.top + b1.height/2 - rect.top);
        ctx.lineTo(b2.left - rect.left, b2.top + b2.height/2 - rect.top);
        ctx.strokeStyle = '#10b981'; ctx.lineWidth = 3; ctx.stroke();
    }

    function renderSelect(data) {
        const container = document.getElementById('game-content');
        const q = document.createElement('h3'); q.innerText = data.q; container.appendChild(q);
        data.options.forEach((opt, i) => {
            const btn = document.createElement('button'); btn.innerText = opt; btn.style.width = "100%";
            btn.onclick = () => { if(i === data.correct) successStep(); else { btn.disabled = true; btn.style.background = "var(--danger)"; handleError(); } };
            container.appendChild(btn);
        });
    }

    function handleError() {
        gameState.lives--;
        updateHUD();
        if(gameState.lives <= 0) { 
            updateRankingTable();
            alert("‚ö†Ô∏è Vidas agotadas. Reiniciando nivel..."); 
            startLevel(gameState.currentLevel); 
        }
    }

    function successStep() {
        gameState.score += 200;
        gameState.currentActivity++;
        updateHUD();
        nextActivity();
    }

    function updateHUD() {
        document.getElementById('lives').innerText = gameState.lives;
        document.getElementById('score').innerText = gameState.score;
    }

    function updateRankingTable() {
        const finalLvlScore = gameState.score + (gameState.lives * 100);
        gameState.rankingHistory.push({
            lvl: gameState.currentLevel,
            diff: gameState.difficulty,
            time: gameState.lvlTime,
            lives: gameState.lives,
            score: finalLvlScore
        });
        const tbody = document.getElementById('ranking-body');
        tbody.innerHTML = "";
        gameState.rankingHistory.forEach(row => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${row.lvl}</td><td>${row.diff}</td><td>${row.time}s</td><td>${row.lives}</td><td style="font-weight:bold; color:var(--primary)">${row.score}</td>`;
            tbody.appendChild(tr);
        });
    }

    function showFinalLeaderboard() {
        const container = document.getElementById('final-leaderboard-container');
        const body = document.getElementById('leaderboard-body');
        container.style.display = "block";
        document.getElementById('btn-next-lvl').style.display = "none";
        
        let totalScore = 0;
        gameState.rankingHistory.forEach(item => totalScore += item.score);
        let average = totalScore / 5;
        let percentage = Math.min(100, (average / 1500) * 100).toFixed(2);

        body.innerHTML = `
            <tr>
                <td style="font-weight:800">${gameState.playerName}</td>
                <td>${gameState.difficulty}</td>
                <td style="color:var(--success); font-weight:800">${percentage}%</td>
            </tr>
        `;

        saveToHistoricalRanking(); // GUARDAR AL HISTORIAL

        const restartBtn = document.createElement('button');
        restartBtn.innerText = "VOLVER AL INICIO üè†";
        restartBtn.style.width = "100%";
        restartBtn.style.marginTop = "15px";
        restartBtn.onclick = () => location.reload();
        container.appendChild(restartBtn);
    }

    function endLevel() {
        clearInterval(gameState.timerInterval);
        confetti();
        const finalLvlScore = gameState.score + (gameState.lives * 100);
        document.getElementById('rank-title').innerText = "¬°Nivel " + gameState.currentLevel + " Completado!";
        document.getElementById('rank-time').innerText = gameState.lvlTime;
        document.getElementById('rank-lives').innerText = gameState.lives;
        document.getElementById('rank-score').innerText = finalLvlScore;
        document.getElementById('rank-grade').innerText = finalLvlScore > 1000 ? "üèÜ S - Experto" : "A - Investigador";
        
        updateRankingTable();
        showScreen('screen-rank');

        if(gameState.currentLevel === 5) {
            showFinalLeaderboard();
        }
    }

    function showScreen(id) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.getElementById(id).classList.add('active');
    }

    // Inicializar tabla hist√≥rica al cargar
    window.onload = loadHistoricalRanking;
</script>
</body>
</html>